---
title: "Page Not Found - RNA Match-3 Paradise"
layout: default
excerpt: "Page not found, but relax with our soothing RNA Match-3 game!"
sitemap: false
permalink: /404.html
---

<style>
/* Modern UI Design */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

* {
    box-sizing: border-box;
}

.game-container {
    max-width: 600px;
    margin: 20px auto;
    padding: 20px;
    text-align: center;
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 20px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.15);
    min-height: 80vh;
}

.game-title {
    color: white;
    font-size: 2.2em;
    font-weight: 700;
    margin-bottom: 10px;
    text-shadow: 0 4px 8px rgba(0,0,0,0.3);
    letter-spacing: -0.5px;
}

.game-subtitle {
    color: rgba(255,255,255,0.9);
    font-size: 1.1em;
    font-weight: 300;
    margin-bottom: 25px;
    line-height: 1.4;
}

.suggestions {
    margin: 20px 0;
    padding: 15px;
    background: rgba(255,255,255,0.15);
    border-radius: 15px;
    color: white;
    display: none;
}

.suggestions-title {
    font-weight: 600;
    margin-bottom: 10px;
}

.suggestions-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.suggestions-list li {
    margin: 5px 0;
}

.suggestions-list a {
    color: #fff;
    text-decoration: underline;
    transition: color 0.3s ease;
}

.suggestions-list a:hover {
    color: #e2e8f0;
}

.game-stats {
    display: flex;
    justify-content: space-around;
    margin-bottom: 20px;
    padding: 15px;
    background: rgba(255,255,255,0.15);
    backdrop-filter: blur(10px);
    border-radius: 15px;
    border: 1px solid rgba(255,255,255,0.2);
}

.stat-item {
    text-align: center;
    color: white;
}

.stat-label {
    font-size: 0.8em;
    font-weight: 500;
    opacity: 0.8;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.stat-value {
    font-size: 1.8em;
    font-weight: 700;
    margin-top: 5px;
    text-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

#gameBoard {
    background: rgba(255,255,255,0.95);
    border-radius: 15px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    margin: 20px auto;
    cursor: pointer;
    user-select: none;
    overflow: hidden;
}

.combo-display {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #ff6b6b;
    font-size: 2em;
    font-weight: 700;
    text-shadow: 0 2px 8px rgba(0,0,0,0.5);
    pointer-events: none;
    opacity: 0;
    animation: comboFade 1s ease-out;
}

@keyframes comboFade {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
    50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
    100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
}

.controls {
    margin: 20px 0;
    padding: 20px;
    background: rgba(255,255,255,0.1);
    border-radius: 15px;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,0.2);
}

.control-title {
    color: white;
    font-weight: 600;
    font-size: 1.1em;
    margin-bottom: 15px;
}

.control-text {
    color: rgba(255,255,255,0.9);
    font-size: 0.95em;
    line-height: 1.6;
}

.nucleotide-legend {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin: 15px 0;
    flex-wrap: wrap;
}

.nucleotide-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    background: rgba(255,255,255,0.15);
    border-radius: 20px;
    color: white;
    font-weight: 500;
    font-size: 0.9em;
}

.nucleotide-color {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.back-home {
    margin-top: 25px;
}

.back-home a {
    background: rgba(255,255,255,0.2);
    color: white;
    padding: 12px 30px;
    text-decoration: none;
    border-radius: 30px;
    font-weight: 600;
    transition: all 0.3s ease;
    display: inline-block;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,0.3);
}

.back-home a:hover {
    background: rgba(255,255,255,0.3);
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0,0,0,0.2);
}

.level-complete {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
}

.level-complete.show {
    opacity: 1;
    pointer-events: all;
}

.level-complete-content {
    background: white;
    padding: 40px;
    border-radius: 20px;
    text-align: center;
    box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    max-width: 400px;
    width: 90%;
}

.next-level-btn {
    background: #667eea;
    color: white;
    border: none;
    padding: 12px 30px;
    border-radius: 25px;
    font-size: 1.1em;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    margin-top: 20px;
}

.next-level-btn:hover {
    background: #5a6fd8;
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
}

.particle {
    position: absolute;
    pointer-events: none;
    border-radius: 50%;
    animation: particle-float 1s ease-out forwards;
}

@keyframes particle-float {
    0% {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
    100% {
        opacity: 0;
        transform: translateY(-100px) scale(0.5);
    }
}

@media (max-width: 768px) {
    .game-container {
        margin: 10px;
        padding: 15px;
    }
    
    .game-title {
        font-size: 1.8em;
    }
    
    .nucleotide-legend {
        gap: 10px;
    }
    
    .nucleotide-item {
        padding: 6px 10px;
        font-size: 0.8em;
    }
}
</style>

<div class="game-container">
    <h1 class="game-title">üß¨ RNA Match-3 Paradise üß¨</h1>
    <p class="game-subtitle">The page got lost, but you found a relaxing RNA elimination paradise! Match identical nucleotides to build fabulous sequences.</p>

    <div id="suggestions" class="suggestions">
        <div class="suggestions-title">Maybe you were looking for:</div>
        <ul class="suggestions-list"></ul>
    </div>

    <div class="game-stats">
        <div class="stat-item">
            <div class="stat-label">Score</div>
            <div class="stat-value" id="score">0</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Level</div>
            <div class="stat-value" id="level">1</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Moves</div>
            <div class="stat-value" id="moves">30</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Target</div>
            <div class="stat-value" id="target">1000</div>
        </div>
    </div>
    
    <canvas id="gameBoard" width="480" height="480"></canvas>
    
    <div class="controls">
        <div class="control-title">üéÆ Gameplay</div>
        <div class="control-text">
            Click and drag neighbouring RNA nucleotides to swap positions and match 3 or more identical nucleotides to eliminate them. Create longer matching chains to get higher scores!
        </div>
        
        <div class="nucleotide-legend">
            <div class="nucleotide-item">
                <div class="nucleotide-color" style="background: #ff6b6b;"></div>
                <span>adenosine (A)</span>
            </div>
            <div class="nucleotide-item">
                <div class="nucleotide-color" style="background: #4ecdc4;"></div>
                <span>uridine (U)</span>
            </div>
            <div class="nucleotide-item">
                <div class="nucleotide-color" style="background: #45b7d1;"></div>
                <span>cytidylic (C)</span>
            </div>
            <div class="nucleotide-item">
                <div class="nucleotide-color" style="background: #96ceb4;"></div>
                <span>guanylic (G)</span>
            </div>
        </div>
    </div>
    
    <div class="back-home">
        <a href="{{ site.url }}{{ site.baseurl }}/">üè† Back to home pageContinue exploring</a>
    </div>
</div>

<div class="level-complete" id="levelComplete">
    <div class="level-complete-content">
        <h2>üéâ Level complete! </h2>
        <p>Congratulations on completing the level!</p>
        <div>Score: <span id="finalScore">0</span></div>
        <button class="next-level-btn" onclick="game.nextLevel()">Next</button>
    </div>
</div>

<script>
class RNAMatch3Game {
    constructor() {
        this.canvas = document.getElementById('gameBoard');
        this.ctx = this.canvas.getContext('2d');
        this.gridSize = 8;
        this.cellSize = 60;
        this.board = [];
        this.score = 0;
        this.level = 1;
        this.moves = 30;
        this.target = 1000;
        this.selectedCell = null;
        this.animating = false;
        this.comboCount = 0;
        this.particles = [];
        
        // RNA nucleotide types and colors
        this.nucleotides = ['A', 'U', 'C', 'G'];
        this.colors = {
            'A': '#ff6b6b',  // Á∫¢Ëâ≤ - ËÖ∫Ëã∑ÈÖ∏
            'U': '#4ecdc4',  // ÈùíËâ≤ - Â∞øËã∑ÈÖ∏
            'C': '#45b7d1',  // ËìùËâ≤ - ËÉûËã∑ÈÖ∏
            'G': '#96ceb4'   // ÁªøËâ≤ - È∏üËã∑ÈÖ∏
        };
        
        this.initGame();
        this.bindEvents();
        this.gameLoop();
    }
    
    initGame() {
        this.generateBoard();
        this.updateUI();
    }
    
    generateBoard() {
        this.board = [];
        for (let row = 0; row < this.gridSize; row++) {
            this.board[row] = [];
            for (let col = 0; col < this.gridSize; col++) {
                let nucleotide;
                do {
                    nucleotide = this.nucleotides[Math.floor(Math.random() * this.nucleotides.length)];
                } while (this.wouldCreateMatch(row, col, nucleotide));
                
                this.board[row][col] = {
                    type: nucleotide,
                    x: col * this.cellSize,
                    y: row * this.cellSize,
                    targetX: col * this.cellSize,
                    targetY: row * this.cellSize,
                    animating: false,
                    scale: 1,
                    rotation: 0
                };
            }
        }
    }
    
    wouldCreateMatch(row, col, type) {
        // Check horizontal
        let hCount = 1;
        if (col >= 2 && this.board[row][col-1] && this.board[row][col-1].type === type &&
            this.board[row][col-2] && this.board[row][col-2].type === type) {
            return true;
        }
        
        // Check vertical
        if (row >= 2 && this.board[row-1] && this.board[row-1][col] && this.board[row-1][col].type === type &&
            this.board[row-2] && this.board[row-2][col] && this.board[row-2][col].type === type) {
            return true;
        }
        
        return false;
    }
    
    bindEvents() {
        this.canvas.addEventListener('click', (e) => this.handleClick(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
    }
    
    handleClick(e) {
        if (this.animating || this.moves <= 0) return;
        
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        const col = Math.floor(x / this.cellSize);
        const row = Math.floor(y / this.cellSize);
        
        if (row < 0 || row >= this.gridSize || col < 0 || col >= this.gridSize) return;
        
        if (!this.selectedCell) {
            this.selectedCell = { row, col };
            this.board[row][col].scale = 1.1;
        } else {
            if (this.selectedCell.row === row && this.selectedCell.col === col) {
                // Deselect
                this.board[row][col].scale = 1;
                this.selectedCell = null;
            } else if (this.areAdjacent(this.selectedCell, { row, col })) {
                // Swap cells
                this.swapCells(this.selectedCell, { row, col });
                this.board[this.selectedCell.row][this.selectedCell.col].scale = 1;
                this.selectedCell = null;
            } else {
                // Select new cell
                this.board[this.selectedCell.row][this.selectedCell.col].scale = 1;
                this.selectedCell = { row, col };
                this.board[row][col].scale = 1.1;
            }
        }
    }
    
    handleMouseMove(e) {
        if (!this.selectedCell) return;
        
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        const col = Math.floor(x / this.cellSize);
        const row = Math.floor(y / this.cellSize);
        
        if (row >= 0 && row < this.gridSize && col >= 0 && col < this.gridSize) {
            this.canvas.style.cursor = this.areAdjacent(this.selectedCell, { row, col }) ? 'pointer' : 'default';
        }
    }
    
    areAdjacent(cell1, cell2) {
        const dx = Math.abs(cell1.col - cell2.col);
        const dy = Math.abs(cell1.row - cell2.row);
        return (dx === 1 && dy === 0) || (dx === 0 && dy === 1);
    }
    
    async swapCells(cell1, cell2) {
        this.animating = true;
        
        // Swap the cells
        const temp = this.board[cell1.row][cell1.col];
        this.board[cell1.row][cell1.col] = this.board[cell2.row][cell2.col];
        this.board[cell2.row][cell2.col] = temp;
        
        // Update positions
        this.board[cell1.row][cell1.col].targetX = cell1.col * this.cellSize;
        this.board[cell1.row][cell1.col].targetY = cell1.row * this.cellSize;
        this.board[cell2.row][cell2.col].targetX = cell2.col * this.cellSize;
        this.board[cell2.row][cell2.col].targetY = cell2.row * this.cellSize;
        
        // Check for matches
        const matches = this.findMatches();
        
        if (matches.length === 0) {
            // No matches, swap back
            const temp2 = this.board[cell1.row][cell1.col];
            this.board[cell1.row][cell1.col] = this.board[cell2.row][cell2.col];
            this.board[cell2.row][cell2.col] = temp2;
            
            this.board[cell1.row][cell1.col].targetX = cell1.col * this.cellSize;
            this.board[cell1.row][cell1.col].targetY = cell1.row * this.cellSize;
            this.board[cell2.row][cell2.col].targetX = cell2.col * this.cellSize;
            this.board[cell2.row][cell2.col].targetY = cell2.row * this.cellSize;
        } else {
            this.moves--;
            this.comboCount = 0;
            await this.processMatches();
        }
        
        this.animating = false;
        this.updateUI();
        this.checkGameState();
    }
    
    findMatches() {
        const matches = [];
        const visited = new Set();
        
        for (let row = 0; row < this.gridSize; row++) {
            for (let col = 0; col < this.gridSize; col++) {
                if (visited.has(`${row},${col}`)) continue;
                
                const horizontalMatch = this.findHorizontalMatch(row, col);
                const verticalMatch = this.findVerticalMatch(row, col);
                
                if (horizontalMatch.length >= 3) {
                    matches.push(...horizontalMatch);
                    horizontalMatch.forEach(cell => visited.add(`${cell.row},${cell.col}`));
                }
                
                if (verticalMatch.length >= 3) {
                    matches.push(...verticalMatch);
                    verticalMatch.forEach(cell => visited.add(`${cell.row},${cell.col}`));
                }
            }
        }
        
        return matches;
    }
    
    findHorizontalMatch(row, col) {
        const type = this.board[row][col].type;
        const match = [{ row, col }];
        
        // Check right
        for (let c = col + 1; c < this.gridSize; c++) {
            if (this.board[row][c].type === type) {
                match.push({ row, col: c });
            } else {
                break;
            }
        }
        
        // Check left
        for (let c = col - 1; c >= 0; c--) {
            if (this.board[row][c].type === type) {
                match.unshift({ row, col: c });
            } else {
                break;
            }
        }
        
        return match;
    }
    
    findVerticalMatch(row, col) {
        const type = this.board[row][col].type;
        const match = [{ row, col }];
        
        // Check down
        for (let r = row + 1; r < this.gridSize; r++) {
            if (this.board[r][col].type === type) {
                match.push({ row: r, col });
            } else {
                break;
            }
        }
        
        // Check up
        for (let r = row - 1; r >= 0; r--) {
            if (this.board[r][col].type === type) {
                match.unshift({ row: r, col });
            } else {
                break;
            }
        }
        
        return match;
    }
    
    async processMatches() {
        let totalMatches = 0;
        
        while (true) {
            const matches = this.findMatches();
            if (matches.length === 0) break;
            
            totalMatches += matches.length;
            this.comboCount++;
            
            // Remove matched cells and create particles
            matches.forEach(match => {
                const cell = this.board[match.row][match.col];
                this.createParticles(match.col * this.cellSize + this.cellSize/2,
                                   match.row * this.cellSize + this.cellSize/2,
                                   this.colors[cell.type]);
                this.board[match.row][match.col] = null;
            });
            
            // Calculate score
            let matchScore = matches.length * 100;
            if (matches.length > 3) matchScore *= (matches.length - 2);
            if (this.comboCount > 1) matchScore *= this.comboCount;
            
            this.score += matchScore;
            
            if (this.comboCount > 1) {
                this.showCombo(this.comboCount);
            }
            
            // Drop cells
            this.dropCells();
            
            // Fill empty spaces
            this.fillBoard();
            
            // Wait for animations
            await this.wait(300);
        }
    }
    
    dropCells() {
        for (let col = 0; col < this.gridSize; col++) {
            let writeRow = this.gridSize - 1;
            
            for (let row = this.gridSize - 1; row >= 0; row--) {
                if (this.board[row][col] !== null) {
                    if (row !== writeRow) {
                        this.board[writeRow][col] = this.board[row][col];
                        this.board[row][col] = null;
                        
                        this.board[writeRow][col].targetY = writeRow * this.cellSize;
                    }
                    writeRow--;
                }
            }
        }
    }
    
    fillBoard() {
        for (let col = 0; col < this.gridSize; col++) {
            for (let row = 0; row < this.gridSize; row++) {
                if (this.board[row][col] === null) {
                    const nucleotide = this.nucleotides[Math.floor(Math.random() * this.nucleotides.length)];
                    this.board[row][col] = {
                        type: nucleotide,
                        x: col * this.cellSize,
                        y: -this.cellSize,
                        targetX: col * this.cellSize,
                        targetY: row * this.cellSize,
                        animating: true,
                        scale: 1,
                        rotation: 0
                    };
                }
            }
        }
    }
    
    createParticles(x, y, color) {
        for (let i = 0; i < 8; i++) {
            this.particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                color: color,
                life: 1,
                decay: 0.02
            });
        }
    }
    
    showCombo(combo) {
        const comboDiv = document.createElement('div');
        comboDiv.className = 'combo-display';
        comboDiv.textContent = `${combo}x Combo!`;
        comboDiv.style.position = 'absolute';
        comboDiv.style.left = '50%';
        comboDiv.style.top = '50%';
        comboDiv.style.transform = 'translate(-50%, -50%)';
        comboDiv.style.zIndex = '1000';
        comboDiv.style.pointerEvents = 'none';
        
        this.canvas.parentElement.appendChild(comboDiv);
        
        setTimeout(() => {
            if (comboDiv.parentElement) {
                comboDiv.parentElement.removeChild(comboDiv);
            }
        }, 1000);
    }
    
    wait(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    updateUI() {
        document.getElementById('score').textContent = this.score;
        document.getElementById('level').textContent = this.level;
        document.getElementById('moves').textContent = this.moves;
        document.getElementById('target').textContent = this.target;
    }
    
    checkGameState() {
        if (this.score >= this.target) {
            this.levelComplete();
        } else if (this.moves <= 0) {
            this.gameOver();
        }
    }
    
    levelComplete() {
        document.getElementById('finalScore').textContent = this.score;
        document.getElementById('levelComplete').classList.add('show');
    }
    
    nextLevel() {
        this.level++;
        this.target = Math.floor(this.target * 1.5);
        this.moves = 30;
        this.comboCount = 0;
        this.generateBoard();
        this.updateUI();
        document.getElementById('levelComplete').classList.remove('show');
    }
    
    gameOver() {
        setTimeout(() => {
            if (confirm(`Game over! Your score: ${this.score}. Would you like to restart?`)) {
                this.restartGame();
            }
        }, 500);
    }
    
    restartGame() {
        this.score = 0;
        this.level = 1;
        this.moves = 30;
        this.target = 1000;
        this.comboCount = 0;
        this.selectedCell = null;
        this.particles = [];
        this.generateBoard();
        this.updateUI();
    }
    
    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw background grid
        this.ctx.strokeStyle = '#e0e0e0';
        this.ctx.lineWidth = 1;
        for (let i = 0; i <= this.gridSize; i++) {
            this.ctx.beginPath();
            this.ctx.moveTo(i * this.cellSize, 0);
            this.ctx.lineTo(i * this.cellSize, this.canvas.height);
            this.ctx.stroke();
            
            this.ctx.beginPath();
            this.ctx.moveTo(0, i * this.cellSize);
            this.ctx.lineTo(this.canvas.width, i * this.cellSize);
            this.ctx.stroke();
        }
        
        // Draw cells
        for (let row = 0; row < this.gridSize; row++) {
            for (let col = 0; col < this.gridSize; col++) {
                const cell = this.board[row][col];
                if (!cell) continue;
                
                // Animate position
                const dx = cell.targetX - cell.x;
                const dy = cell.targetY - cell.y;
                if (Math.abs(dx) > 1 || Math.abs(dy) > 1) {
                    cell.x += dx * 0.2;
                    cell.y += dy * 0.2;
                } else {
                    cell.x = cell.targetX;
                    cell.y = cell.targetY;
                }
                
                this.ctx.save();
                this.ctx.translate(cell.x + this.cellSize/2, cell.y + this.cellSize/2);
                this.ctx.scale(cell.scale, cell.scale);
                this.ctx.rotate(cell.rotation);
                
                // Draw nucleotide
                const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, this.cellSize/2 - 5);
                gradient.addColorStop(0, this.colors[cell.type]);
                gradient.addColorStop(1, this.adjustColor(this.colors[cell.type], -20));
                
                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, this.cellSize/2 - 5, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Draw shadow
                this.ctx.fillStyle = 'rgba(0,0,0,0.1)';
                this.ctx.beginPath();
                this.ctx.arc(2, 2, this.cellSize/2 - 5, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Draw letter
                this.ctx.fillStyle = 'white';
                this.ctx.font = 'bold 18px Inter';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(cell.type, 0, 0);
                
                this.ctx.restore();
            }
        }
        
        // Draw selection highlight
        if (this.selectedCell) {
            const cell = this.selectedCell;
            this.ctx.strokeStyle = '#fff';
            this.ctx.lineWidth = 3;
            this.ctx.setLineDash([5, 5]);
            this.ctx.strokeRect(cell.col * this.cellSize + 3, cell.row * this.cellSize + 3,
                              this.cellSize - 6, this.cellSize - 6);
            this.ctx.setLineDash([]);
        }
        
        // Draw particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const particle = this.particles[i];
            particle.x += particle.vx;
            particle.y += particle.vy;
            particle.life -= particle.decay;
            
            if (particle.life <= 0) {
                this.particles.splice(i, 1);
                continue;
            }
            
            this.ctx.fillStyle = `${particle.color}${Math.floor(particle.life * 255).toString(16).padStart(2, '0')}`;
            this.ctx.beginPath();
            this.ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }
    
    adjustColor(color, amount) {
        const num = parseInt(color.replace("#", ""), 16);
        const amt = Math.round(2.55 * amount);
        const R = (num >> 16) + amt;
        const G = (num >> 8 & 0x00FF) + amt;
        const B = (num & 0x0000FF) + amt;
        return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
            (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
            (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
    }
    
    gameLoop() {
        this.draw();
        requestAnimationFrame(() => this.gameLoop());
    }
}

// Start the game
let game;
window.addEventListener('load', () => {
    game = new RNAMatch3Game();
});
</script>

<script>
fetch('{{ site.baseurl }}/search.json')
    .then(response => response.json())
    .then(data => {
        const path = window.location.pathname.toLowerCase();

        const slug = decodeURIComponent(
            path
                .split('/')
                .pop()
                .replace(/\.html$/, '')
                .replace(/[-_]+/g, ' ')
        );
        const tokens = slug.split(/\s+/).filter(Boolean);
        if (!tokens.length) return;

        const matches = data
            .filter(item => !/404\.html$/.test(item.url))
            .map(item => {
                const haystack = (item.title + ' ' + item.url).toLowerCase();
                const count = tokens.filter(t => haystack.includes(t)).length;
                return Object.assign({}, item, { count });
            })
            .filter(item => item.count > 0)
            .sort((a, b) => b.count - a.count)
            .slice(0, 3);

        if (matches.length) {
            const container = document.getElementById('suggestions');
            const list = container.querySelector('.suggestions-list');
            matches.forEach(m => {
                const li = document.createElement('li');
                const a = document.createElement('a');
                a.href = m.url;
                a.textContent = m.title;
                li.appendChild(a);
                list.appendChild(li);
            });
            container.style.display = 'block';
        }
    })
    .catch(err => console.error('Failed to load suggestions', err));
</script>


